
--- lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'providers/user_provider.dart';
import 'providers/theme_provider.dart';
import 'services/api_service.dart';
import 'views/welcome_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final prefs = await SharedPreferences.getInstance();
  print('Main: Initializing app, SharedPreferences ready');
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => UserProvider()),
        Provider(create: (context) => ApiService()),
        ChangeNotifierProvider(create: (context) => ThemeProvider()),
      ],
      child: const PetformApp(),
    ),
  );
}

class PetformApp extends StatelessWidget {
  const PetformApp({super.key});

  @override
  Widget build(BuildContext context) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    return MaterialApp(
      title: 'Petform',
      theme: ThemeData(
        brightness: Brightness.dark,
        colorScheme: ColorScheme.dark(
          primary: Colors.blue[800]!,
          secondary: Colors.orange,
          surface: Colors.grey[900]!,
        ),
        scaffoldBackgroundColor: Colors.grey[900],
        appBarTheme: AppBarTheme(
          backgroundColor: Colors.grey[900],
          titleTextStyle: const TextStyle(color: Colors.white, fontSize: 20),
          iconTheme: const IconThemeData(color: Colors.white),
        ),
        bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: Colors.grey[850],
          selectedItemColor: Colors.orange,
          unselectedItemColor: Colors.grey[400],
          selectedLabelStyle: const TextStyle(color: Colors.orange),
          unselectedLabelStyle: TextStyle(color: Colors.grey[400]),
        ),
        dropdownMenuTheme: DropdownMenuThemeData(
          menuStyle: MenuStyle(
            backgroundColor: WidgetStateProperty.all(Colors.grey[800]),
            surfaceTintColor: WidgetStateProperty.all(Colors.grey[800]),
          ),
          textStyle: const TextStyle(color: Colors.white),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.grey[800],
          hintStyle: TextStyle(color: Colors.grey[400]),
          labelStyle: const TextStyle(color: Colors.white),
          border: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.orange),
          ),
        ),
        cardTheme: CardThemeData(
          color: Colors.grey[850],
          surfaceTintColor: Colors.grey[850],
        ),
        popupMenuTheme: PopupMenuThemeData(
          color: Colors.grey[800],
          textStyle: const TextStyle(color: Colors.white),
          surfaceTintColor: Colors.grey[800],
        ),
        floatingActionButtonTheme: const FloatingActionButtonThemeData(
          backgroundColor: Colors.orange,
          foregroundColor: Colors.white,
        ),
        textTheme: ThemeData.dark().textTheme.copyWith(
              bodyLarge: TextStyle(color: Colors.white),
              bodyMedium: TextStyle(color: Colors.white70),
              headlineLarge: TextStyle(color: Colors.white),
            ),
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        colorScheme: ColorScheme.dark(
          primary: Colors.blue[800]!,
          secondary: Colors.orange,
          surface: Colors.grey[900]!,
        ),
        scaffoldBackgroundColor: Colors.grey[900],
        appBarTheme: AppBarTheme(
          backgroundColor: Colors.grey[900],
          titleTextStyle: const TextStyle(color: Colors.white, fontSize: 20),
          iconTheme: const IconThemeData(color: Colors.white),
        ),
        bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: Colors.grey[850],
          selectedItemColor: Colors.orange,
          unselectedItemColor: Colors.grey[400],
          selectedLabelStyle: const TextStyle(color: Colors.orange),
          unselectedLabelStyle: TextStyle(color: Colors.grey[400]),
        ),
        dropdownMenuTheme: DropdownMenuThemeData(
          menuStyle: MenuStyle(
            backgroundColor: WidgetStateProperty.all(Colors.grey[800]),
            surfaceTintColor: WidgetStateProperty.all(Colors.grey[800]),
          ),
          textStyle: const TextStyle(color: Colors.white),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.grey[800],
          hintStyle: TextStyle(color: Colors.grey[400]),
          labelStyle: const TextStyle(color: Colors.white),
          border: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.orange),
          ),
        ),
        cardTheme: CardThemeData(
          color: Colors.grey[850],
          surfaceTintColor: Colors.grey[850],
        ),
        popupMenuTheme: PopupMenuThemeData(
          color: Colors.grey[800],
          textStyle: const TextStyle(color: Colors.white),
          surfaceTintColor: Colors.grey[800],
        ),
        floatingActionButtonTheme: const FloatingActionButtonThemeData(
          backgroundColor: Colors.orange,
          foregroundColor: Colors.white,
        ),
        textTheme: ThemeData.dark().textTheme.copyWith(
              bodyLarge: TextStyle(color: Colors.white),
              bodyMedium: TextStyle(color: Colors.white70),
              headlineLarge: TextStyle(color: Colors.white),
            ),
      ),
      themeMode: themeProvider.themeMode,
      home: const WelcomeScreen(),
    );
  }
}

--- lib/providers/feed_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import '../services/api_service.dart';
import '../models/post.dart';

class FeedProvider with ChangeNotifier {
  String _selectedPetType = 'All';
  String _selectedPostType = 'All';
  List<Post> _posts = [];
  bool _isLoading = false;

  String get selectedPetType => _selectedPetType;
  String get selectedPostType => _selectedPostType;
  List<Post> get posts => _posts;
  bool get isLoading => _isLoading;

  void setPetType(String petType) {
    _selectedPetType = petType;
    notifyListeners();
  }

  void setPostType(String postType) {
    _selectedPostType = postType;
    notifyListeners();
  }

  Future<void> fetchPosts(BuildContext context) async {
    _isLoading = true;
    notifyListeners();

    try {
      final apiService = ApiService();
      _posts = await apiService.getPosts(
        petType: _selectedPetType == 'All' ? null : _selectedPetType,
        postType: _selectedPostType == 'All' ? null : _selectedPostType,
      );
      if (kDebugMode) {
        print('FeedProvider: fetched ${_posts.length} posts');
      }
    } catch (e) {
      _posts = [];
      if (kDebugMode) {
        print('FeedProvider: error fetching posts: $e');
      }
    }

    _isLoading = false;
    notifyListeners();
  }
}


--- lib/providers/user_provider.dart ---
import 'package:flutter/foundation.dart';
import '../services/api_service.dart';
import '../models/pet.dart';

class UserProvider with ChangeNotifier {
  String? _email;
  List<Pet> _pets = [];
  final ApiService _apiService = ApiService();

  String? get email => _email;
  List<Pet> get pets => _pets;
  bool get isLoggedIn => _email != null;

  Future<void> setUser(String email) async {
    _email = email;
    try {
      _pets = await _apiService.getPets();
      if (kDebugMode) {
        print('UserProvider: Set user $email with ${_pets.length} pets');
      }
    } catch (e) {
      if (kDebugMode) {
        print('UserProvider: Error loading pets: $e');
      }
      _pets = [];
    }
    notifyListeners();
  }

  void clearUser() {
    _email = null;
    _pets = [];
    if (kDebugMode) {
      print('UserProvider: Cleared user');
    }
    notifyListeners();
  }
}

--- lib/providers/theme_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeProvider with ChangeNotifier {
  ThemeMode _themeMode = ThemeMode.dark;

  ThemeMode get themeMode => _themeMode;

  ThemeProvider() {
    _loadTheme();
  }

  Future<void> _loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    final isDarkMode = prefs.getBool('isDarkMode') ?? true;
    _themeMode = isDarkMode ? ThemeMode.dark : ThemeMode.light;
    if (kDebugMode) {
      print('ThemeProvider: Loaded theme: $_themeMode');
    }
    notifyListeners();
  }

  Future<void> toggleTheme() async {
    _themeMode = _themeMode == ThemeMode.dark ? ThemeMode.light : ThemeMode.dark;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('isDarkMode', _themeMode == ThemeMode.dark);
    if (kDebugMode) {
      print('ThemeProvider: Toggled theme to $_themeMode');
    }
    notifyListeners();
  }
}

--- lib/models/tracking_metric.dart ---
class TrackingMetric {
  final String? id;
  final String? petId;
  final String? name;
  final String? frequency;
  DateTime? lastCompletion;
  List<MetricHistory> history;
  bool isCompleted;

  TrackingMetric({
    this.id,
    this.petId,
    this.name,
    this.frequency,
    this.lastCompletion,
    this.history = const [],
    this.isCompleted = false,
  });

  factory TrackingMetric.fromJson(Map<String, dynamic> json) {
    return TrackingMetric(
      id: json['id'] as String?,
      petId: json['petId'] as String?,
      name: json['name'] as String?,
      frequency: json['frequency'] as String?,
      lastCompletion: json['lastCompletion'] != null
          ? DateTime.parse(json['lastCompletion'] as String)
          : null,
      isCompleted: json['isCompleted'] as bool? ?? false,
      history: (json['history'] as List<dynamic>?)
              ?.map((h) => MetricHistory.fromJson(h as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'petId': petId,
      'name': name,
      'frequency': frequency,
      'lastCompletion': lastCompletion?.toIso8601String(),
      'isCompleted': isCompleted,
      'history': history.map((h) => h.toJson()).toList(),
    };
  }
}

class MetricHistory {
  final DateTime timestamp;
  final String? value;

  MetricHistory({required this.timestamp, this.value});

  factory MetricHistory.fromJson(Map<String, dynamic> json) {
    return MetricHistory(
      timestamp: DateTime.parse(json['timestamp'] as String),
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'value': value,
    };
  }
}


--- lib/models/tracking_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:provider/provider.dart';
import '../models/pet.dart';
import '../models/tracking_metric.dart';
import '../services/api_service.dart';

class TrackingProvider with ChangeNotifier {
  List<TrackingMetric> _metrics = [];
  bool _isLoading = false;

  List<TrackingMetric> get metrics => _metrics;
  bool get isLoading => _isLoading;

  Future<void> loadMetrics(BuildContext context) async {
    _isLoading = true;
    notifyListeners();
    
    try {
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      if (userProvider.pets.isNotEmpty) {
        final pet = userProvider.pets.first;
        _metrics = pet.trackingMetrics;
        
        if (kDebugMode) {
          print('TrackingProvider: Loaded ${_metrics.length} metrics');
        }
      }
    } catch (e) {
      _metrics = [];
      if (kDebugMode) {
        print('TrackingProvider: Error loading metrics: $e');
      }
    }
    
    _isLoading = false;
    notifyListeners();
  }
  
  Future<void> addMetric(BuildContext context, TrackingMetric newMetric) async {
    try {
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      final apiService = Provider.of<ApiService>(context, listen: false);
      
      if (userProvider.pets.isNotEmpty) {
        final pet = userProvider.pets.first;
        pet.trackingMetrics.add(newMetric);
        await apiService.updatePet(pet);
        await loadMetrics(context);
      }
    } catch (e) {
      if (kDebugMode) {
        print('TrackingProvider: Error adding metric: $e');
      }
      rethrow;
    }
  }
  
  Future<void> deleteMetric(BuildContext context, TrackingMetric metric) async {
    try {
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      final apiService = Provider.of<ApiService>(context, listen: false);
      
      if (userProvider.pets.isNotEmpty) {
        final pet = userProvider.pets.first;
        pet.trackingMetrics.removeWhere((m) => m.name == metric.name);
        await apiService.updatePet(pet);
        await loadMetrics(context);
      }
    } catch (e) {
      if (kDebugMode) {
        print('TrackingProvider: Error deleting metric: $e');
      }
      rethrow;
    }
  }
}

--- lib/models/shopping_item.dart ---
class ShoppingItem {
  final String name;
  final bool isPurchased;
  final String? url;
  final String? category;
  final int? quantity;
  final String? notes;

  ShoppingItem({
    required this.name,
    this.isPurchased = false,
    this.url,
    this.category,
    this.quantity,
    this.notes,
  });

  factory ShoppingItem.fromJson(Map<String, dynamic> json) {
    return ShoppingItem(
      name: json['name'] as String,
      isPurchased: json['isPurchased'] as bool? ?? false,
      url: json['url'] as String?,
      category: json['category'] as String?,
      quantity: json['quantity'] as int?,
      notes: json['notes'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'isPurchased': isPurchased,
      'url': url,
      'category': category,
      'quantity': quantity,
      'notes': notes,
    };
  }
}

--- lib/models/post.dart ---
class Comment {
  final int? id;
  final String content;
  final String author;
  final DateTime createdAt;

  Comment({
    this.id,
    required this.content,
    required this.author,
    required this.createdAt,
  });

  factory Comment.fromJson(Map<String, dynamic> json) {
    return Comment(
      id: json['id'] as int?,
      content: json['content'] as String,
      author: json['author'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'content': content,
      'author': author,
      'createdAt': createdAt.toIso8601String(),
    };
  }
}

class Post {
  final int? id;
  final String title;
  final String content;
  final String author;
  final String petType;
  final String? imageUrl;
  final int? upvotes;
  final DateTime createdAt;
  final String postType;
  final String? redditUrl;
  final List<Comment> comments;

  Post({
    this.id,
    required this.title,
    required this.content,
    required this.author,
    required this.petType,
    this.imageUrl,
    this.upvotes,
    required this.createdAt,
    required this.postType,
    this.redditUrl,
    this.comments = const [],
  });

  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(
      id: json['id'] as int?,
      title: json['title'] as String,
      content: json['content'] as String,
      author: json['author'] as String,
      petType: json['petType'] as String,
      imageUrl: json['imageUrl'] as String?,
      upvotes: json['upvotes'] as int?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      postType: json['postType'] as String,
      redditUrl: json['redditUrl'] as String?,
      comments: (json['comments'] as List<dynamic>?)
          ?.map((c) => Comment.fromJson(c as Map<String, dynamic>))
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'content': content,
      'author': author,
      'petType': petType,
      'imageUrl': imageUrl,
      'upvotes': upvotes,
      'createdAt': createdAt.toIso8601String(),
      'postType': postType,
      'redditUrl': redditUrl,
      'comments': comments.map((c) => c.toJson()).toList(),
    };
  }
}

--- lib/models/user.dart ---
import 'pet.dart';

class User {
  final int id;
  final String email;
  final List<Pet> pets;

  User({required this.id, required this.email, required this.pets});

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as int,
      email: json['email'] as String,
      pets: (json['pets'] as List<dynamic>? ?? []).map((p) => Pet.fromJson(p)).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'pets': pets.map((p) => p.toJson()).toList(),
    };
  }
}


--- lib/models/pet.dart ---
import 'shopping_item.dart';
import 'tracking_metric.dart';

class Pet {
  final int id;
  final String name;
  final String species;
  final String? breed;
  final int? age;
  final String? personality;
  final String? foodSource;
  final String? favoritePark;
  final String? leashSource;
  final String? litterType;
  final String? waterProducts;
  final String? tankSize;
  final String? cageSize;
  final String? favoriteToy;
  final Map<String, dynamic> customFields;
  final List<ShoppingItem> shoppingList;
  final List<TrackingMetric> trackingMetrics;

  Pet({
    required this.id,
    required this.name,
    required this.species,
    this.breed,
    this.age,
    this.personality,
    this.foodSource,
    this.favoritePark,
    this.leashSource,
    this.litterType,
    this.waterProducts,
    this.tankSize,
    this.cageSize,
    this.favoriteToy,
    this.customFields = const {},
    this.shoppingList = const [],
    this.trackingMetrics = const [],
  });

  factory Pet.fromJson(Map<String, dynamic> json) {
    return Pet(
      id: json['id'] as int,
      name: json['name'] as String,
      species: json['species'] as String,
      breed: json['breed'] as String?,
      age: json['age'] as int?,
      personality: json['personality'] as String?,
      foodSource: json['foodSource'] as String?,
      favoritePark: json['favoritePark'] as String?,
      leashSource: json['leashSource'] as String?,
      litterType: json['litterType'] as String?,
      waterProducts: json['waterProducts'] as String?,
      tankSize: json['tankSize'] as String?,
      cageSize: json['cageSize'] as String?,
      favoriteToy: json['favoriteToy'] as String?,
      customFields: json['customFields'] as Map<String, dynamic>? ?? {},
      shoppingList: (json['shoppingList'] as List<dynamic>?)
          ?.map((item) => ShoppingItem.fromJson(item as Map<String, dynamic>))
          .toList() ?? [],
      trackingMetrics: (json['trackingMetrics'] as List<dynamic>?)
          ?.map((m) => TrackingMetric.fromJson(m as Map<String, dynamic>))
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'species': species,
      'breed': breed,
      'age': age,
      'personality': personality,
      'foodSource': foodSource,
      'favoritePark': favoritePark,
      'leashSource': leashSource,
      'litterType': litterType,
      'waterProducts': waterProducts,
      'tankSize': tankSize,
      'cageSize': cageSize,
      'favoriteToy': favoriteToy,
      'customFields': customFields,
      'shoppingList': shoppingList.map((item) => item.toJson()).toList(),
      'trackingMetrics': trackingMetrics.map((m) => m.toJson()).toList(),
    };
  }
}

--- lib/models/reddit_post.dart ---
class RedditPost {
  final String title;
  final String subreddit;
  final String author;
  final String url;
  final String thumbnail;

  RedditPost({
    required this.title,
    required this.subreddit,
    required this.author,
    required this.url,
    required this.thumbnail,
  });

  factory RedditPost.fromJson(Map<String, dynamic> json) {
    final data = json['data'];
    return RedditPost(
      title: data['title'] ?? '',
      subreddit: data['subreddit'] ?? '',
      author: data['author'] ?? '',
      url: 'https://www.reddit.com${data['permalink']}',
      thumbnail: data['thumbnail'] ?? '',
    );
  }
}


--- lib/views/comment_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/post.dart';
import '../services/api_service.dart';
import '../providers/user_provider.dart';
import '../widgets/rounded_button.dart';

class CommentScreen extends StatefulWidget {
  final Post post;

  const CommentScreen({super.key, required this.post});

  @override
  _CommentScreenState createState() => _CommentScreenState();
}

class _CommentScreenState extends State<CommentScreen> {
  final _commentController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }

  Future<void> _addComment() async {
    if (_commentController.text.trim().isEmpty) return;

    setState(() => _isLoading = true);
    try {
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      await Provider.of<ApiService>(context, listen: false).addComment(
        postId: widget.post.id!,
        content: _commentController.text,
        author: userProvider.email ?? 'Anonymous',
      );
      if (!mounted) return;
      _commentController.clear();
      setState(() {});
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to add comment: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Comments')),
      body: FutureBuilder<Post>(
        future: Provider.of<ApiService>(context, listen: false).getPost(widget.post.id!),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError || !snapshot.hasData) {
            return const Center(child: Text('Failed to load comments'));
          }
          final post = snapshot.data!;
          return Column(
            children: [
              Expanded(
                child: ListView.builder(
                  padding: const EdgeInsets.all(16.0),
                  itemCount: post.comments.length,
                  itemBuilder: (context, index) {
                    final comment = post.comments[index];
                    return Card(
                      margin: const EdgeInsets.symmetric(vertical: 8),
                      child: ListTile(
                        title: Text(comment.author, style: const TextStyle(fontWeight: FontWeight.bold)),
                        subtitle: Text(comment.content),
                        trailing: Text(
                          '${comment.createdAt.day}/${comment.createdAt.month}/${comment.createdAt.year}',
                          style: TextStyle(color: Colors.grey[400], fontSize: 12),
                        ),
                      ),
                    );
                  },
                ),
              ),
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _commentController,
                        decoration: const InputDecoration(
                          hintText: 'Add a comment...',
                          border: OutlineInputBorder(),
                          filled: true,
                        ),
                        onSubmitted: (_) => _addComment(),
                      ),
                    ),
                    const SizedBox(width: 8),
                    _isLoading
                        ? const CircularProgressIndicator()
                        : IconButton(
                            icon: const Icon(Icons.send),
                            onPressed: _addComment,
                          ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

--- lib/views/shopping_item.dart ---
class ShoppingItem {
  final String name;
  final bool isPurchased;
  final String? url;
  final String? category;
  final int? quantity;
  final String? notes;

  ShoppingItem({
    required this.name,
    this.isPurchased = false,
    this.url,
    this.category,
    this.quantity,
    this.notes,
  });

  factory ShoppingItem.fromJson(Map<String, dynamic> json) {
    return ShoppingItem(
      name: json['name'] as String,
      isPurchased: json['isPurchased'] as bool,
      url: json['url'] as String?,
      category: json['category'] as String?,
      quantity: json['quantity'] as int?,
      notes: json['notes'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'isPurchased': isPurchased,
      'url': url,
      'category': category,
      'quantity': quantity,
      'notes': notes,
    };
  }
}

--- lib/views/metric_detail_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/tracking_metric.dart';
import '../providers/user_provider.dart';
import '../services/api_service.dart';

class MetricDetailScreen extends StatefulWidget {
  final TrackingMetric metric;

  const MetricDetailScreen({super.key, required this.metric});

  @override
  _MetricDetailScreenState createState() => _MetricDetailScreenState();
}

class _MetricDetailScreenState extends State<MetricDetailScreen> {
  final _valueController = TextEditingController();
  bool _isSaving = false;

  Future<void> _addEntry() async {
    if (_valueController.text.isEmpty) return;
    
    setState(() {
      widget.metric.history.add(
        MetricHistory(
          timestamp: DateTime.now(),
          value: _valueController.text,
        ),
      );
      widget.metric.lastCompletion = DateTime.now();
    });
    
    _valueController.clear();

    try {
      setState(() => _isSaving = true);
      
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      final apiService = Provider.of<ApiService>(context, listen: false);
      
      if (userProvider.pets.isNotEmpty) {
        final pet = userProvider.pets.first;
        await apiService.updatePet(pet);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to save: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(widget.metric.name ?? 'Metric Detail')),
      body: Column(
        children: [
          Expanded(
            child: widget.metric.history.isEmpty
                ? const Center(
                    child: Text(
                      'No entries yet\nAdd your first entry below',
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 18, color: Colors.grey),
                    ),
                  )
                : ListView.builder(
                    padding: const EdgeInsets.only(top: 16),
                    itemCount: widget.metric.history.length,
                    itemBuilder: (context, index) {
                      final entry = widget.metric.history[index];
                      return Card(
                        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                        child: ListTile(
                          title: Text(entry.value ?? 'No value'),
                          subtitle: Text(
                            '${entry.timestamp.day}/${entry.timestamp.month}/${entry.timestamp.year} '
                            '${entry.timestamp.hour}:${entry.timestamp.minute.toString().padLeft(2, '0')}',
                            style: TextStyle(color: Colors.grey[500]),
                          ),
                        ),
                      );
                    },
                  ),
          ),
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _valueController,
                    decoration: InputDecoration(
                      labelText: 'Enter ${widget.metric.name} value',
                      border: const OutlineInputBorder(),
                      filled: true,
                    ),
                    onSubmitted: (_) => _addEntry(),
                  ),
                ),
                const SizedBox(width: 10),
                _isSaving
                    ? const CircularProgressIndicator()
                    : IconButton(
                        onPressed: _addEntry,
                        icon: const Icon(Icons.add),
                        iconSize: 32,
                        style: IconButton.styleFrom(
                          backgroundColor: Theme.of(context).colorScheme.secondary,
                          foregroundColor: Colors.white,
                        ),
                      ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

--- lib/views/post_detail_screen.dart ---
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:url_launcher/url_launcher.dart';
import '../models/post.dart';
import 'comment_screen.dart';
import '../widgets/rounded_button.dart';

class PostDetailScreen extends StatelessWidget {
  final Post post;

  const PostDetailScreen({super.key, required this.post});

  Future<void> _launchRedditUrl(String url) async {
    final uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      throw 'Could not launch $url';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(post.title)),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                CircleAvatar(child: Text(post.author[0])),
                const SizedBox(width: 8),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      post.author,
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    Text(
                      '${post.petType} • ${post.postType[0].toUpperCase()}${post.postType.substring(1)}',
                      style: TextStyle(color: Colors.grey[400], fontSize: 12),
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              post.title,
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            if (post.imageUrl != null)
              CachedNetworkImage(
                imageUrl: post.imageUrl!,
                placeholder: (context, url) => const CircularProgressIndicator(),
                errorWidget: (context, url, error) => const SizedBox.shrink(),
                width: double.infinity,
                fit: BoxFit.cover,
              ),
            const SizedBox(height: 8),
            Text(post.content, style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 16),
            Row(
              children: [
                Icon(Icons.thumb_up, size: 16, color: Colors.grey[400]),
                const SizedBox(width: 4),
                Text('${post.upvotes ?? 0}'),
                if (post.postType == 'community') ...[
                  const SizedBox(width: 16),
                  Icon(Icons.comment, size: 16, color: Colors.grey[400]),
                  const SizedBox(width: 4),
                  Text('${post.comments.length}'),
                ],
                const Spacer(),
                Text(
                  '${post.createdAt.day}/${post.createdAt.month}/${post.createdAt.year}',
                  style: TextStyle(color: Colors.grey[400], fontSize: 12),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (post.postType == 'reddit' && post.redditUrl != null)
              RoundedButton(
                text: 'Open in Reddit',
                onPressed: () => _launchRedditUrl(post.redditUrl!),
              ),
            if (post.postType == 'community')
              RoundedButton(
                text: 'View Comments',
                onPressed: () => Navigator.push(
                  context,
                  MaterialPageRoute(builder: (context) => CommentScreen(post: post)),
                ),
              ),
            ],
          ),
        ),
      
    );
  }
}

--- lib/views/add_metric_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/tracking_provider.dart';
import '../models/tracking_metric.dart';

class AddMetricScreen extends StatefulWidget {
  const AddMetricScreen({super.key});

  @override
  _AddMetricScreenState createState() => _AddMetricScreenState();
}

class _AddMetricScreenState extends State<AddMetricScreen> {
  final _nameController = TextEditingController();
  String _selectedFrequency = 'Daily';
  final List<String> _frequencies = ['Daily', 'Weekly', 'Monthly', 'As Needed'];

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final trackingProvider = Provider.of<TrackingProvider>(context, listen: false);
    
    return Scaffold(
      appBar: AppBar(title: const Text('Add Tracking Metric')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(
                labelText: 'Metric Name',
                border: OutlineInputBorder(),
                filled: true,
              ),
            ),
            const SizedBox(height: 20),
            const Text('Frequency:', style: TextStyle(fontSize: 16)),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _frequencies.map((frequency) {
                return ChoiceChip(
                  label: Text(frequency),
                  selected: _selectedFrequency == frequency,
                  onSelected: (selected) {
                    setState(() {
                      _selectedFrequency = frequency;
                    });
                  },
                );
              }).toList(),
            ),
            const Spacer(),
            Center(
              child: ElevatedButton(
                onPressed: () {
                  if (_nameController.text.isNotEmpty) {
                    final newMetric = TrackingMetric(
                      name: _nameController.text,
                      frequency: _selectedFrequency,
                      history: [],
                    );
                    trackingProvider.addMetric(context, newMetric);
                    Navigator.pop(context);
                  }
                },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text('Add Metric', style: TextStyle(fontSize: 18)),
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }
}

--- lib/views/profile_settings_screen.dart ---
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/pet.dart';
import '../models/post.dart';
import '../models/shopping_item.dart';
import '../providers/user_provider.dart';
import '../providers/theme_provider.dart';
import '../services/api_service.dart';
import 'welcome_screen.dart';
import '../widgets/rounded_button.dart';

class ProfileSettingsScreen extends StatelessWidget {
  const ProfileSettingsScreen({super.key});

  Future<Pet?> _loadPet() async {
    final prefs = await SharedPreferences.getInstance();
    final pets = prefs.getString('pets') ?? '[]';
    final petsList = jsonDecode(pets) as List;
    if (petsList.isEmpty) return null;
    return Pet.fromJson(petsList.first as Map<String, dynamic>);
  }

  Future<List<Post>> _loadUserPosts(String email) async {
    final prefs = await SharedPreferences.getInstance();
    final posts = jsonDecode(prefs.getString('posts') ?? '[]') as List;
    return posts
        .map((p) => Post.fromJson(p as Map<String, dynamic>))
        .where((post) => post.author == email)
        .toList();
  }

  Future<List<Comment>> _loadUserComments(String email) async {
    final prefs = await SharedPreferences.getInstance();
    final posts = jsonDecode(prefs.getString('posts') ?? '[]') as List;
    final comments = <Comment>[];
    for (var post in posts) {
      final postComments = (post['comments'] as List<dynamic>?)
          ?.map((c) => Comment.fromJson(c as Map<String, dynamic>))
          .where((comment) => comment.author == email)
          .toList() ?? [];
      comments.addAll(postComments);
    }
    return comments;
  }

  Future<void> _addShoppingItem(BuildContext context, Pet pet) async {
    String name = '';
    String url = '';
    String category = '';
    int? quantity;
    String notes = '';
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: const Text('Add Shopping Item'),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextField(
                      decoration: const InputDecoration(labelText: 'Item Name'),
                      onChanged: (value) => name = value,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'URL (Optional)'),
                      onChanged: (value) => url = value,
                      keyboardType: TextInputType.url,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Category (Optional)'),
                      onChanged: (value) => category = value,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Quantity (Optional)'),
                      onChanged: (value) => quantity = int.tryParse(value),
                      keyboardType: TextInputType.number,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Notes (Optional)'),
                      onChanged: (value) => notes = value,
                      maxLines: 3,
                    ),
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () {
                    if (name.trim().isNotEmpty) {
                      Navigator.pop(context, {
                        'name': name,
                        'url': url.isNotEmpty ? url : null,
                        'category': category.isNotEmpty ? category : null,
                        'quantity': quantity,
                        'notes': notes.isNotEmpty ? notes : null,
                      });
                    }
                  },
                  child: const Text('Add'),
                ),
              ],
            );
          },
        );
      },
    );

    if (result != null) {
      pet.shoppingList.add(ShoppingItem(
        name: result['name'] as String,
        url: result['url'] as String?,
        category: result['category'] as String?,
        quantity: result['quantity'] as int?,
        notes: result['notes'] as String?,
      ));
      await Provider.of<ApiService>(context, listen: false).updatePet(pet);
      if (kDebugMode) {
        print('ProfileSettingsScreen: Added shopping item ${result['name']}');
      }
      (context as Element).markNeedsBuild();
    }
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    final themeProvider = Provider.of<ThemeProvider>(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'User: ${userProvider.email ?? 'N/A'}',
                style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              SwitchListTile(
                title: const Text('Dark Mode'),
                value: themeProvider.themeMode == ThemeMode.dark,
                onChanged: (value) => themeProvider.toggleTheme(),
                activeColor: Theme.of(context).colorScheme.secondary,
              ),
              const SizedBox(height: 16),
              FutureBuilder<Pet?>(
                future: _loadPet(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  if (snapshot.hasError || !snapshot.hasData) {
                    return const Text('No pet added yet', style: TextStyle(fontSize: 16));
                  }
                  final pet = snapshot.data!;
                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Pet Profile',
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 8),
                      Text('Name: ${pet.name}', style: const TextStyle(fontSize: 16)),
                      Text('Species: ${pet.species}', style: const TextStyle(fontSize: 16)),
                      if (pet.breed != null) Text('Breed: ${pet.breed}', style: const TextStyle(fontSize: 16)),
                      if (pet.age != null) Text('Age: ${pet.age}', style: const TextStyle(fontSize: 16)),
                      if (pet.personality != null) Text('Personality: ${pet.personality}', style: const TextStyle(fontSize: 16)),
                      if (pet.foodSource != null) Text('Food Source: ${pet.foodSource}', style: const TextStyle(fontSize: 16)),
                      if (pet.favoritePark != null) Text('Favorite Park: ${pet.favoritePark}', style: const TextStyle(fontSize: 16)),
                      if (pet.leashSource != null) Text('Leash Source: ${pet.leashSource}', style: const TextStyle(fontSize: 16)),
                      if (pet.litterType != null) Text('Litter Type: ${pet.litterType}', style: const TextStyle(fontSize: 16)),
                      if (pet.waterProducts != null) Text('Water Products: ${pet.waterProducts}', style: const TextStyle(fontSize: 16)),
                      if (pet.tankSize != null) Text('Tank Size: ${pet.tankSize}', style: const TextStyle(fontSize: 16)),
                      if (pet.cageSize != null) Text('Cage Size: ${pet.cageSize}', style: const TextStyle(fontSize: 16)),
                      if (pet.favoriteToy != null) Text('Favorite Toy: ${pet.favoriteToy}', style: const TextStyle(fontSize: 16)),
                      if (pet.customFields.isNotEmpty) ...[
                        const SizedBox(height: 8),
                        const Text('Custom Fields', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                        ...pet.customFields.entries.map((e) => Text('${e.key}: ${e.value}', style: const TextStyle(fontSize: 16))),
                      ],
                      const SizedBox(height: 16),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text('Shopping List Items', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                          RoundedButton(
                            text: 'Add Item',
                            onPressed: () => _addShoppingItem(context, pet),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      if (pet.shoppingList.isEmpty)
                        const Text('No items added yet', style: TextStyle(fontSize: 16))
                      else
                        ...pet.shoppingList.map((item) => Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(item.name, style: const TextStyle(fontSize: 16)),
                                if (item.isPurchased) const Text('(Purchased)', style: TextStyle(fontSize: 14, color: Colors.green)),
                                if (item.category != null) Text('Category: ${item.category}', style: const TextStyle(fontSize: 14)),
                                if (item.quantity != null) Text('Quantity: ${item.quantity}', style: const TextStyle(fontSize: 14)),
                                if (item.notes != null) Text('Notes: ${item.notes}', style: const TextStyle(fontSize: 14)),
                                if (item.url != null) Text('URL: ${item.url}', style: TextStyle(fontSize: 14, color: Theme.of(context).colorScheme.secondary)),
                                const SizedBox(height: 8),
                              ],
                            )),
                    ],
                  );
                },
              ),
              const SizedBox(height: 16),
              FutureBuilder<List<Post>>(
                future: _loadUserPosts(userProvider.email ?? ''),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  final posts = snapshot.data ?? [];
                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Your Posts', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                      if (posts.isEmpty)
                        const Text('No posts yet', style: TextStyle(fontSize: 16))
                      else
                        ...posts.map((post) => Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(post.title, style: const TextStyle(fontSize: 16)),
                                Text('Type: ${post.postType[0].toUpperCase()}${post.postType.substring(1)}', style: const TextStyle(fontSize: 14)),
                                const SizedBox(height: 8),
                              ],
                            )),
                    ],
                  );
                },
              ),
              const SizedBox(height: 16),
              FutureBuilder<List<Comment>>(
                future: _loadUserComments(userProvider.email ?? ''),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  final comments = snapshot.data ?? [];
                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Your Comments', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                      if (comments.isEmpty)
                        const Text('No comments yet', style: TextStyle(fontSize: 16))
                      else
                        ...comments.map((comment) => Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(comment.content, style: const TextStyle(fontSize: 16)),
                                Text('Posted: ${comment.createdAt.day}/${comment.createdAt.month}/${comment.createdAt.year}',
                                    style: const TextStyle(fontSize: 14)),
                                const SizedBox(height: 8),
                              ],
                            )),
                    ],
                  );
                },
              ),
              const SizedBox(height: 16),
              RoundedButton(
                text: 'Sign Out',
                onPressed: () {
                  userProvider.clearUser();
                  Navigator.pushReplacement(
                    context,
                    MaterialPageRoute(builder: (context) => const WelcomeScreen()),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

--- lib/views/ask_ai_screen.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class AiMessage {
  final String text;
  final bool isUser;
  final String promptTemplate;

  AiMessage({
    required this.text,
    required this.isUser,
    required this.promptTemplate,
  });
}

class AiProvider with ChangeNotifier {
  String _selectedPrompt = 'My pet is feeling ___'; // Default prompt
  List<AiMessage> _messages = [];
  bool _isLoading = false;

  String get selectedPrompt => _selectedPrompt;
  List<AiMessage> get messages => _messages;
  bool get isLoading => _isLoading;

  void setPrompt(String prompt) {
    _selectedPrompt = prompt;
    notifyListeners();
  }

  void sendMessage(String userInput) {
    if (userInput.trim().isEmpty) return;

    _isLoading = true;
    notifyListeners();

    // Add user message
    _messages.add(AiMessage(
      text: '$_selectedPrompt: $userInput',
      isUser: true,
      promptTemplate: _selectedPrompt,
    ));

    // Simulate AI response placeholder (no mock service)
    // Future server integration will add AI response here

    _isLoading = false;
    notifyListeners();
  }

  void clearChat() {
    _messages = [];
    notifyListeners();
  }
}

class PromptDropdown extends StatelessWidget {
  const PromptDropdown({super.key});

  @override
  Widget build(BuildContext context) {
    final aiProvider = Provider.of<AiProvider>(context);
    const prompts = [
      'My pet is feeling ___',
      'My pet is ___',
      'My pet needs help with ___',
      'My pet ate ___',
    ];

    return Padding(
      padding: const EdgeInsets.only(top: 48.0, left: 16.0, right: 16.0, bottom: 8.0), // Notch padding
      child: DropdownButtonFormField<String>(
        value: aiProvider.selectedPrompt,
        decoration: InputDecoration(
          labelText: 'Select a Prompt',
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          filled: true, // Rely on inputDecorationTheme.fillColor
        ),
        items: prompts.map((prompt) {
          return DropdownMenuItem(
            value: prompt,
            child: Text(prompt),
          );
        }).toList(),
        onChanged: (value) {
          if (value != null) {
            aiProvider.setPrompt(value);
          }
        },
      ),
    );
  }
}

class MessageBubble extends StatelessWidget {
  final AiMessage message;

  const MessageBubble({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: message.isUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 16.0),
        padding: const EdgeInsets.all(12.0),
        decoration: BoxDecoration(
          color: message.isUser ? Colors.blue[800] : Colors.grey[700],
          borderRadius: BorderRadius.circular(12.0),
        ),
        child: Text(
          message.text,
          style: const TextStyle(fontSize: 14, color: Colors.white),
        ),
      ),
    );
  }
}

class AskAiScreen extends StatelessWidget {
  const AskAiScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => AiProvider(),
      builder: (context, child) {
        final aiProvider = Provider.of<AiProvider>(context);
        final textController = TextEditingController();

        return Scaffold(
          appBar: AppBar(
            title: const Text('Ask AI'),
            actions: [
              IconButton(
                icon: const Icon(Icons.delete),
                onPressed: () => aiProvider.clearChat(),
                tooltip: 'Clear Chat',
              ),
            ],
          ),
          body: Column(
            children: [
              const PromptDropdown(),
              Expanded(
                child: aiProvider.messages.isEmpty
                    ? const Center(child: Text('Start a conversation!'))
                    : ListView.builder(
                        itemCount: aiProvider.messages.length,
                        itemBuilder: (context, index) {
                          return MessageBubble(message: aiProvider.messages[index]);
                        },
                      ),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: textController,
                        decoration: InputDecoration(
                          hintText: 'Fill in the blank...',
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          filled: true, // Rely on inputDecorationTheme.fillColor
                        ),
                        onSubmitted: (value) {
                          aiProvider.sendMessage(value);
                          textController.clear();
                        },
                      ),
                    ),
                    const SizedBox(width: 8),
                    aiProvider.isLoading
                        ? const CircularProgressIndicator()
                        : IconButton(
                            icon: const Icon(Icons.send),
                            onPressed: () {
                              aiProvider.sendMessage(textController.text);
                              textController.clear();
                            },
                          ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}


--- lib/views/signup_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../services/api_service.dart';
import '../providers/user_provider.dart';
import 'pet_profile_creation_screen.dart';
import '../widgets/rounded_button.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({super.key});

  @override
  _SignupScreenState createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;

  void _signup() async {
    setState(() => _isLoading = true);
    try {
      final apiService = Provider.of<ApiService>(context, listen: false);
      await apiService.signup(_emailController.text, _passwordController.text);
      await apiService.login(_emailController.text, _passwordController.text);
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      await userProvider.setUser(_emailController.text);
      if (!mounted) return;
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const PetProfileCreationScreen()),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Signup failed: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Sign Up')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(
              controller: _emailController,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            TextField(
              controller: _passwordController,
              decoration: const InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
            const SizedBox(height: 20),
            _isLoading
                ? const CircularProgressIndicator()
                : RoundedButton(text: 'Sign Up', onPressed: _signup),
          ],
        ),
      ),
    );
  }
}

--- lib/views/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../models/pet.dart';

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Pet Profile')),
      body: FutureBuilder<Pet>(
        future: _loadPet(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError || !snapshot.hasData) {
            return Center(child: Text('Error loading pet'));
          }
          final pet = snapshot.data!;
          return Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Name: ${pet.name}', style: TextStyle(fontSize: 18)),
                Text('Species: ${pet.species}', style: TextStyle(fontSize: 18)),
                SizedBox(height: 10),
                ...pet.customFields.entries.map((entry) {
                  return Text('${entry.key}: ${entry.value}', style: TextStyle(fontSize: 16));
                }),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<Pet> _loadPet() async {
    final prefs = await SharedPreferences.getInstance();
    final pets = prefs.getString('pets') ?? '[]';
    final petsList = jsonDecode(pets) as List;
    if (petsList.isEmpty) throw Exception('No pet found');
    return Pet.fromJson(petsList.first as Map<String, dynamic>);
  }
}

--- lib/views/community_feed_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shimmer/shimmer.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../models/post.dart';
import '../providers/feed_provider.dart';
import 'post_detail_screen.dart';
import 'create_post_screen.dart';

class FeedFilter extends StatelessWidget {
  const FeedFilter({super.key});

  @override
  Widget build(BuildContext context) {
    final feedProvider = Provider.of<FeedProvider>(context);
    const petTypes = ['All', 'Dog', 'Cat', 'Turtle'];
    const postTypes = ['All', 'Reddit', 'Community'];

    return Container(
      padding: const EdgeInsets.only(top: 48, left: 16, right: 16, bottom: 8),
      child: Row(
        children: [
          Expanded(
            child: DropdownButtonFormField<String>(
              value: feedProvider.selectedPetType,
              decoration: const InputDecoration(
                labelText: 'Filter by Pet',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.all(Radius.circular(12)),
                ),
                filled: true,
              ),
              items: petTypes.map((type) {
                return DropdownMenuItem(value: type, child: Text(type));
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  feedProvider.setPetType(value);
                  feedProvider.fetchPosts(context);
                }
              },
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: DropdownButtonFormField<String>(
              value: feedProvider.selectedPostType,
              decoration: const InputDecoration(
                labelText: 'Filter by Post Type',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.all(Radius.circular(12)),
                ),
                filled: true,
              ),
              items: postTypes.map((type) {
                return DropdownMenuItem(value: type, child: Text(type));
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  feedProvider.setPostType(value);
                  feedProvider.fetchPosts(context);
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

class PostCard extends StatelessWidget {
  final Post post;

  const PostCard({super.key, required this.post});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => PostDetailScreen(post: post)),
        );
      },
      child: Card(
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  CircleAvatar(child: Text(post.author.isNotEmpty ? post.author[0] : '?')),
                  const SizedBox(width: 8),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        post.author,
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                      Text(
                        '${post.petType} • ${post.postType[0].toUpperCase()}${post.postType.substring(1)}',
                        style: TextStyle(color: Colors.grey[400], fontSize: 12),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                post.title,
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 4),
              if (post.imageUrl != null)
                CachedNetworkImage(
                  imageUrl: post.imageUrl!,
                  placeholder: (context, url) => const CircularProgressIndicator(),
                  errorWidget: (context, url, error) => const SizedBox.shrink(),
                  width: double.infinity,
                  fit: BoxFit.cover,
                ),
              const SizedBox(height: 4),
              Text(post.content, style: const TextStyle(fontSize: 14)),
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(Icons.thumb_up, size: 16, color: Colors.grey[400]),
                  const SizedBox(width: 4),
                  Text('${post.upvotes ?? 0}'),
                  if (post.postType == 'community') ...[
                    const SizedBox(width: 16),
                    Icon(Icons.comment, size: 16, color: Colors.grey[400]),
                    const SizedBox(width: 4),
                    Text('${post.comments.length}'),
                  ],
                  const Spacer(),
                  Text(
                    '${post.createdAt.day}/${post.createdAt.month}/${post.createdAt.year}',
                    style: TextStyle(color: Colors.grey[400], fontSize: 12),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class CommunityFeedScreen extends StatelessWidget {
  const CommunityFeedScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => FeedProvider()..fetchPosts(context),
      child: Consumer<FeedProvider>(
        builder: (context, feedProvider, child) {
          return Scaffold(
            body: RefreshIndicator(
              onRefresh: () => feedProvider.fetchPosts(context),
              child: Column(
                children: [
                  const FeedFilter(),
                  Expanded(
                    child: feedProvider.isLoading
                        ? ListView.builder(
                            itemCount: 5,
                            itemBuilder: (context, index) {
                              return Shimmer.fromColors(
                                baseColor: Colors.grey[700]!,
                                highlightColor: Colors.grey[600]!,
                                child: Container(
                                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                  height: 150,
                                  color: Colors.grey[850],
                                ),
                              );
                            },
                          )
                        : feedProvider.posts.isEmpty
                            ? const Center(child: Text('No posts found'))
                            : ListView.builder(
                                itemCount: feedProvider.posts.length,
                                itemBuilder: (context, index) {
                                  return PostCard(post: feedProvider.posts[index]);
                                },
                              ),
                  ),
                ],
              ),
            ),
            floatingActionButton: FloatingActionButton(
              onPressed: () => Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const CreatePostScreen()),
              ),
              backgroundColor: Theme.of(context).colorScheme.secondary,
              child: const Icon(Icons.add, color: Colors.white),
            ),
          );
        },
      ),
    );
  }
}


--- lib/views/create_post_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../services/api_service.dart';
import '../providers/user_provider.dart';
import '../widgets/rounded_button.dart';

class CreatePostScreen extends StatefulWidget {
  const CreatePostScreen({super.key});

  @override
  _CreatePostScreenState createState() => _CreatePostScreenState();
}

class _CreatePostScreenState extends State<CreatePostScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _contentController = TextEditingController();
  String _selectedPetType = 'Dog';
  final List<String> _petTypes = ['Dog', 'Cat', 'Turtle', 'Bird'];
  bool _isLoading = false;

  @override
  void dispose() {
    _titleController.dispose();
    _contentController.dispose();
    super.dispose();
  }

  Future<void> _submitPost() async {
    if (_formKey.currentState!.validate()) {
      setState(() => _isLoading = true);
      try {
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        await Provider.of<ApiService>(context, listen: false).createPost(
          title: _titleController.text,
          content: _contentController.text,
          petType: _selectedPetType,
          author: userProvider.email ?? 'Anonymous',
        );
        if (!mounted) return;
        Navigator.pop(context);
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to create post: $e')),
        );
      } finally {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Post')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              DropdownButtonFormField<String>(
                value: _selectedPetType,
                decoration: const InputDecoration(
                  labelText: 'Pet Type',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                items: _petTypes.map((type) {
                  return DropdownMenuItem(value: type, child: Text(type));
                }).toList(),
                onChanged: (value) {
                  setState(() {
                    _selectedPetType = value!;
                  });
                },
                validator: (value) => value == null ? 'Please select a pet type' : null,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _titleController,
                decoration: const InputDecoration(
                  labelText: 'Title',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                validator: (value) =>
                    value == null || value.trim().isEmpty ? 'Please enter a title' : null,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _contentController,
                decoration: const InputDecoration(
                  labelText: 'Content',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                maxLines: 5,
                validator: (value) =>
                    value == null || value.trim().isEmpty ? 'Please enter content' : null,
              ),
              const SizedBox(height: 16),
              _isLoading
                  ? const Center(child: CircularProgressIndicator())
                  : RoundedButton(text: 'Submit Post', onPressed: _submitPost),
            ],
          ),
        ),
      ),
    );
  }
}

--- lib/views/tracking_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/pet.dart';
import '../models/tracking_metric.dart';
import '../providers/user_provider.dart';
import '../services/api_service.dart';
import 'metric_detail_screen.dart';

class TrackingScreen extends StatelessWidget {
  const TrackingScreen({super.key});

  Future<void> _addMetric(BuildContext context, Pet pet) async {
    final result = await showDialog<Map<String, String>>(
      context: context,
      builder: (context) => _MetricDialog(),
    );

    if (result != null && result['name'] != null && result['frequency'] != null) {
      final newMetric = TrackingMetric(
        id: '${pet.id}-${pet.trackingMetrics.length}',
        petId: pet.id.toString(),
        name: result['name'],
        frequency: result['frequency'],
      );

      pet.trackingMetrics.add(newMetric);
      await Provider.of<ApiService>(context, listen: false).updatePet(pet);
      (context as Element).markNeedsBuild();
    }
  }

  Future<void> _removeMetric(BuildContext context, Pet pet, TrackingMetric metric) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Metric'),
        content: Text('Are you sure you want to remove "${metric.name}"?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancel')),
          TextButton(onPressed: () => Navigator.pop(context, true), child: const Text('Remove')),
        ],
      ),
    );

    if (confirmed == true) {
      pet.trackingMetrics.remove(metric);
      await Provider.of<ApiService>(context, listen: false).updatePet(pet);
      (context as Element).markNeedsBuild();
    }
  }

  void _toggleCompletion(BuildContext context, Pet pet, TrackingMetric metric) async {
    metric.isCompleted = !metric.isCompleted;
    metric.lastCompletion = metric.isCompleted ? DateTime.now() : null;
    await Provider.of<ApiService>(context, listen: false).updatePet(pet);
    (context as Element).markNeedsBuild();
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    if (userProvider.pets.isEmpty) {
      return const Scaffold(body: Center(child: Text('No pet added yet')));
    }
    final pet = userProvider.pets.first;
    final metrics = pet.trackingMetrics;

    return Scaffold(
      appBar: AppBar(title: const Text('Tracking')),
      body: ListView.builder(
        itemCount: metrics.length,
        itemBuilder: (context, index) {
          final metric = metrics[index];
          return ListTile(
            title: Text(metric.name ?? 'Unnamed Metric'),
            subtitle: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Frequency: ${metric.frequency ?? 'N/A'}'),
                Text('Last: ${metric.lastCompletion?.toString() ?? 'N/A'}'),
              ],
            ),
            trailing: Wrap(
              spacing: 8,
              children: [
                IconButton(
                  icon: Icon(
                    metric.isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,
                    color: metric.isCompleted ? Colors.green : Colors.grey,
                  ),
                  onPressed: () => _toggleCompletion(context, pet, metric),
                ),
                IconButton(
                  icon: const Icon(Icons.delete),
                  onPressed: () => _removeMetric(context, pet, metric),
                ),
              ],
            ),
            onTap: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (context) => MetricDetailScreen(metric: metric)),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _addMetric(context, pet),
        child: const Icon(Icons.add),
      ),
    );
  }
}

class _MetricDialog extends StatefulWidget {
  @override
  __MetricDialogState createState() => __MetricDialogState();
}

class __MetricDialogState extends State<_MetricDialog> {
  final _nameController = TextEditingController();
  String? _selectedFrequency;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Add Metric'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(labelText: 'Metric Name'),
          ),
          const SizedBox(height: 10),
          DropdownButtonFormField<String>(
            decoration: const InputDecoration(labelText: 'Frequency'),
            items: ['Daily', 'Weekly', 'Monthly']
                .map((f) => DropdownMenuItem(value: f, child: Text(f)))
                .toList(),
            onChanged: (value) => setState(() => _selectedFrequency = value),
          ),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
        TextButton(
          onPressed: () {
            Navigator.pop(context, {
              'name': _nameController.text,
              'frequency': _selectedFrequency ?? 'Unspecified',
            });
          },
          child: const Text('Add'),
        ),
      ],
    );
  }
}


--- lib/views/pet_detail_screen.dart ---
import 'package:flutter/material.dart';
import 'package:petform/models/pet.dart';

class PetDetailScreen extends StatelessWidget {
  final Pet pet;

  const PetDetailScreen({super.key, required this.pet});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(pet.name)),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Species: ${pet.species}'),
            if (pet.breed != null) Text('Breed: ${pet.breed}'),
            if (pet.age != null) Text('Age: ${pet.age}'),
            if (pet.personality != null) Text('Personality: ${pet.personality}'),
            if (pet.foodSource != null) Text('Food Source: ${pet.foodSource}'),
            if (pet.favoritePark != null) Text('Favorite Park: ${pet.favoritePark}'),
            if (pet.leashSource != null) Text('Leash Source: ${pet.leashSource}'),
            if (pet.litterType != null) Text('Litter Type: ${pet.litterType}'),
            if (pet.waterProducts != null) Text('Water Products: ${pet.waterProducts}'),
          ],
        ),
      ),
    );
  }
}


--- lib/views/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../services/api_service.dart';
import '../providers/user_provider.dart';
import 'home_screen.dart';
import '../widgets/rounded_button.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;

  void _login() async {
    setState(() => _isLoading = true);
    try {
      final apiService = Provider.of<ApiService>(context, listen: false);
      await apiService.login(_emailController.text, _passwordController.text);
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      await userProvider.setUser(_emailController.text);
      if (!mounted) return;
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (context) => const HomeScreen()),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Login failed: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(
              controller: _emailController,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            TextField(
              controller: _passwordController,
              decoration: const InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
            const SizedBox(height: 20),
            _isLoading
                ? const CircularProgressIndicator()
                : RoundedButton(text: 'Log In', onPressed: _login),
          ],
        ),
      ),
    );
  }
}

--- lib/views/feed_screen.dart ---
import 'package:flutter/material.dart';
import 'package:petform/services/api_service.dart';
import 'package:petform/models/post.dart';
import 'package:petform/views/post_detail_screen.dart';

class FeedScreen extends StatefulWidget {
  const FeedScreen({super.key});

  @override
  _FeedScreenState createState() => _FeedScreenState();
}

class _FeedScreenState extends State<FeedScreen> {
  final ApiService _apiService = ApiService();
  List<Post> _posts = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _fetchPosts();
  }

  Future<void> _fetchPosts() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    try {
      final posts = await _apiService.getPosts();
      setState(() {
        _posts = posts;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = 'Failed to load posts: $e';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Pet Community Feed')),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(_errorMessage!, style: const TextStyle(color: Colors.red)),
                      ElevatedButton(
                        onPressed: _fetchPosts,
                        child: const Text('Retry'),
                      ),
                    ],
                  ),
                )
              : RefreshIndicator(
                  onRefresh: _fetchPosts,
                  child: ListView.builder(
                    itemCount: _posts.length,
                    itemBuilder: (context, index) {
                      final post = _posts[index];
                      return ListTile(
                        title: Text(post.title ?? 'No Title'),
                        subtitle: Text(post.selftext ?? 'No Content'),
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => PostDetailScreen(post: post),
                            ),
                          );
                        },
                      );
                    },
                  ),
                ),
    );
  }
}

--- lib/views/shopping_list_screen.dart ---
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:url_launcher/url_launcher.dart';
import '../models/pet.dart';
import '../models/shopping_item.dart';
import '../widgets/rounded_button.dart';

class ShoppingListScreen extends StatefulWidget {
  const ShoppingListScreen({super.key});

  @override
  _ShoppingListScreenState createState() => _ShoppingListScreenState();
}

class _ShoppingListScreenState extends State<ShoppingListScreen> {
  Future<Pet> _loadPet() async {
    final prefs = await SharedPreferences.getInstance();
    final pets = prefs.getString('pets') ?? '[]';
    final petsList = jsonDecode(pets) as List;
    if (petsList.isEmpty) throw Exception('No pet found');
    return Pet.fromJson(petsList.first as Map<String, dynamic>);
  }

  Future<void> _togglePurchaseStatus(Pet pet, ShoppingItem item) async {
    final index = pet.shoppingList.indexWhere((i) => i.name == item.name);
    if (index != -1) {
      pet.shoppingList[index] = ShoppingItem(
        name: item.name,
        isPurchased: !item.isPurchased,
        url: item.url,
        category: item.category,
        quantity: item.quantity,
        notes: item.notes,
      );
      final prefs = await SharedPreferences.getInstance();
      final pets = jsonDecode(prefs.getString('pets') ?? '[]') as List;
      if (pets.isNotEmpty) {
        pets[0] = pet.toJson();
        await prefs.setString('pets', jsonEncode(pets));
        if (kDebugMode) {
          print('ShoppingListScreen: Toggled purchase status for ${item.name}');
        }
      }
      if (mounted) setState(() {});
    }
  }

  Future<void> _addOrEditItem(Pet pet, {ShoppingItem? existingItem}) async {
    String name = existingItem?.name ?? '';
    String url = existingItem?.url ?? '';
    String category = existingItem?.category ?? '';
    int? quantity = existingItem?.quantity;
    String notes = existingItem?.notes ?? '';
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Text(existingItem == null ? 'Add Shopping Item' : 'Edit Shopping Item'),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextField(
                      decoration: const InputDecoration(labelText: 'Item Name'),
                      onChanged: (value) => name = value,
                      controller: TextEditingController(text: name)
                        ..selection = TextSelection.fromPosition(TextPosition(offset: name.length)),
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'URL (Optional)'),
                      onChanged: (value) => url = value,
                      controller: TextEditingController(text: url)
                        ..selection = TextSelection.fromPosition(TextPosition(offset: url.length)),
                      keyboardType: TextInputType.url,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Category (Optional)'),
                      onChanged: (value) => category = value,
                      controller: TextEditingController(text: category)
                        ..selection = TextSelection.fromPosition(TextPosition(offset: category.length)),
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Quantity (Optional)'),
                      onChanged: (value) => quantity = int.tryParse(value),
                      controller: TextEditingController(text: quantity?.toString() ?? '')
                        ..selection = TextSelection.fromPosition(TextPosition(offset: (quantity?.toString() ?? '').length)),
                      keyboardType: TextInputType.number,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      decoration: const InputDecoration(labelText: 'Notes (Optional)'),
                      onChanged: (value) => notes = value,
                      controller: TextEditingController(text: notes)
                        ..selection = TextSelection.fromPosition(TextPosition(offset: notes.length)),
                      maxLines: 3,
                    ),
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () {
                    if (name.trim().isNotEmpty) {
                      Navigator.pop(context, {
                        'name': name,
                        'url': url.isNotEmpty ? url : null,
                        'category': category.isNotEmpty ? category : null,
                        'quantity': quantity,
                        'notes': notes.isNotEmpty ? notes : null,
                      });
                    }
                  },
                  child: const Text('Save'),
                ),
              ],
            );
          },
        );
      },
    );

    if (result != null) {
      final newItem = ShoppingItem(
        name: result['name'],
        isPurchased: existingItem?.isPurchased ?? false,
        url: result['url'],
        category: result['category'],
        quantity: result['quantity'],
        notes: result['notes'],
      );
      final prefs = await SharedPreferences.getInstance();
      final pets = jsonDecode(prefs.getString('pets') ?? '[]') as List;
      if (pets.isNotEmpty) {
        final petData = Pet.fromJson(pets[0]);
        if (existingItem != null) {
          final index = petData.shoppingList.indexWhere((i) => i.name == existingItem.name);
          if (index != -1) petData.shoppingList[index] = newItem;
        } else {
          petData.shoppingList.add(newItem);
        }
        pets[0] = petData.toJson();
        await prefs.setString('pets', jsonEncode(pets));
        if (kDebugMode) {
          print('ShoppingListScreen: ${existingItem == null ? 'Added' : 'Edited'} item ${result['name']}');
        }
      }
      if (mounted) setState(() {});
    }
  }

  Future<void> _deleteItem(Pet pet, ShoppingItem item) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Item'),
        content: Text('Are you sure you want to delete "${item.name}"?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      pet.shoppingList.removeWhere((i) => i.name == item.name);
      final prefs = await SharedPreferences.getInstance();
      final pets = jsonDecode(prefs.getString('posts') ?? '[]') as List;
      if (pets.isNotEmpty) {
        pets[0] = pet.toJson();
        await prefs.setString('pets', jsonEncode(pets));
        if (kDebugMode) {
          print('ShoppingListScreen: Deleted item ${item.name}');
        }
      }
      if (mounted) setState(() {});
    }
  }

  Future<void> _launchUrl(String url) async {
    final uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Could not launch $url')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Shopping List')),
      body: FutureBuilder<Pet>(
        future: _loadPet(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError || !snapshot.hasData) {
            return const Center(child: Text('No pet found'));
          }
          final pet = snapshot.data!;
          if (pet.shoppingList.isEmpty) {
            return const Center(child: Text('No shopping items added yet'));
          }
          return ListView(
            padding: const EdgeInsets.all(16.0),
            children: pet.shoppingList.map((item) {
              return Card(
                margin: const EdgeInsets.symmetric(vertical: 8),
                child: ListTile(
                  title: Text(item.name),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (item.category != null) Text('Category: ${item.category}'),
                      if (item.quantity != null) Text('Quantity: ${item.quantity}'),
                      if (item.notes != null) Text('Notes: ${item.notes}'),
                      if (item.url != null)
                        GestureDetector(
                          onTap: () => _launchUrl(item.url!),
                          child: Text(
                            item.url!,
                            style: TextStyle(
                              color: Theme.of(context).colorScheme.secondary,
                              decoration: TextDecoration.underline,
                            ),
                          ),
                        ),
                    ],
                  ),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      if (item.isPurchased)
                        const Icon(Icons.check_circle, color: Colors.green)
                      else
                        RoundedButton(
                          text: 'Purchased',
                          onPressed: () => _togglePurchaseStatus(pet, item),
                        ),
                      IconButton(
                        icon: const Icon(Icons.edit),
                        onPressed: () => _addOrEditItem(pet, existingItem: item),
                      ),
                      IconButton(
                        icon: const Icon(Icons.delete),
                        onPressed: () => _deleteItem(pet, item),
                      ),
                    ],
                  ),
                ),
              );
            }).toList(),
          );
        },
      ),
      floatingActionButton: FutureBuilder<Pet>(
        future: _loadPet(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) return const SizedBox.shrink();
          final pet = snapshot.data!;
          return FloatingActionButton(
            onPressed: () => _addOrEditItem(pet),
            child: const Icon(Icons.add),
          );
        },
      ),
    );
  }
}

--- lib/views/welcome_screen.dart ---
import 'package:flutter/material.dart';
import 'signup_screen.dart';
import 'login_screen.dart';
import 'home_screen.dart';
import '../widgets/rounded_button.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            RoundedButton(
              text: 'Sign Up',
              onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (context) => const SignupScreen())),
            ),
            const SizedBox(height: 10),
            RoundedButton(
              text: 'Log In',
              onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (context) => const LoginScreen())),
            ),
            const SizedBox(height: 10),
            RoundedButton(
              text: 'Continue as Guest',
              onPressed: () => Navigator.pushReplacement(context, MaterialPageRoute(builder: (context) => const HomeScreen())),
            ),
          ],
        ),
      ),
    );
  }
}

--- lib/views/pet_profile_creation_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/pet.dart';
import '../models/tracking_metric.dart';
import '../services/api_service.dart';
import '../providers/user_provider.dart';
import 'home_screen.dart';
import '../widgets/rounded_button.dart';

class PetProfileCreationScreen extends StatefulWidget {
  const PetProfileCreationScreen({super.key});

  @override
  _PetProfileCreationScreenState createState() => _PetProfileCreationScreenState();
}

class _PetProfileCreationScreenState extends State<PetProfileCreationScreen> {
  final _formKey = GlobalKey<FormState>();
  String _selectedPetType = 'Dog';
  final _nameController = TextEditingController();
  final _ageController = TextEditingController();
  final _breedController = TextEditingController();
  final _personalityController = TextEditingController();
  final _foodSourceController = TextEditingController();
  final Map<String, TextEditingController> _additionalFieldControllers = {};
  final List<MapEntry<String, TextEditingController>> _customFields = [];

  final Map<String, List<String>> _petFields = {
    'Dog': ['Favorite Park', 'Leash Source', 'Favorite Toy'],
    'Cat': ['Litter Type'],
    'Turtle': ['Tank Size', 'Water Products'],
    'Bird': ['Cage Size'],
  };

  final List<String> _petTypes = ['Dog', 'Cat', 'Turtle', 'Bird'];

  List<TrackingMetric> getDefaultMetrics(String petType) {
    switch (petType) {
      case 'Dog':
        return [
          TrackingMetric(name: 'Weight', frequency: 'Monthly'),
          TrackingMetric(name: 'Exercise', frequency: 'Daily'),
          TrackingMetric(name: 'Feeding', frequency: 'Daily'),
        ];
      case 'Cat':
        return [
          TrackingMetric(name: 'Weight', frequency: 'Monthly'),
          TrackingMetric(name: 'Litter Box', frequency: 'Daily'),
        ];
      case 'Turtle':
        return [
          TrackingMetric(name: 'Weight', frequency: 'Monthly'),
          TrackingMetric(name: 'Water Temperature', frequency: 'Daily'),
        ];
      case 'Bird':
        return [
          TrackingMetric(name: 'Weight', frequency: 'Monthly'),
          TrackingMetric(name: 'Flight Time', frequency: 'Daily'),
        ];
      default:
        return [
          TrackingMetric(name: 'Weight', frequency: 'Monthly'),
        ];
    }
  }

  @override
  void initState() {
    super.initState();
    _petFields.forEach((petType, fields) {
      for (var field in fields) {
        _additionalFieldControllers['$petType-$field'] = TextEditingController();
      }
    });
  }

  @override
  void dispose() {
    _nameController.dispose();
    _ageController.dispose();
    _breedController.dispose();
    _personalityController.dispose();
    _foodSourceController.dispose();
    _additionalFieldControllers.forEach((key, controller) => controller.dispose());
    for (var entry in _customFields) {
      entry.value.dispose();
    }
    super.dispose();
  }

  void _addCustomField() {
    setState(() {
      final controller = TextEditingController();
      _customFields.add(MapEntry('Custom Field ${_customFields.length + 1}', controller));
    });
  }

  Future<void> _submitForm() async {
    if (_formKey.currentState!.validate()) {
      final additionalFields = <String, String>{};
      for (var field in _petFields[_selectedPetType] ?? []) {
        additionalFields[field] = _additionalFieldControllers['$_selectedPetType-$field']?.text ?? '';
      }
      final customFields = <String, String>{};
      for (var entry in _customFields) {
        if (entry.value.text.trim().isNotEmpty) {
          customFields[entry.key] = entry.value.text;
        }
      }

      final pet = Pet(
        id: DateTime.now().millisecondsSinceEpoch,
        name: _nameController.text,
        species: _selectedPetType,
        breed: _breedController.text.isNotEmpty ? _breedController.text : null,
        age: int.tryParse(_ageController.text),
        personality: _personalityController.text.isNotEmpty ? _personalityController.text : null,
        foodSource: _foodSourceController.text.isNotEmpty ? _foodSourceController.text : null,
        favoritePark: additionalFields['Favorite Park'],
        leashSource: additionalFields['Leash Source'],
        litterType: additionalFields['Litter Type'],
        waterProducts: additionalFields['Water Products'],
        tankSize: additionalFields['Tank Size'],
        cageSize: additionalFields['Cage Size'],
        favoriteToy: additionalFields['Favorite Toy'],
        customFields: customFields,
        shoppingList: [],
        trackingMetrics: getDefaultMetrics(_selectedPetType),
      );

      try {
        await Provider.of<ApiService>(context, listen: false).createPet(pet);
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        await userProvider.setUser(userProvider.email!);
        if (!mounted) return;
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const HomeScreen()),
        );
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to create pet: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Pet Profile')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              DropdownButtonFormField<String>(
                value: _selectedPetType,
                decoration: const InputDecoration(
                  labelText: 'Pet Type',
                  border: OutlineInputBorder(),
                ),
                items: _petTypes.map((String type) {
                  return DropdownMenuItem<String>(
                    value: type,
                    child: Text(type),
                  );
                }).toList(),
                onChanged: (String? newValue) {
                  setState(() {
                    _selectedPetType = newValue!;
                  });
                },
                validator: (value) {
                  if (value == null) return 'Please select a pet type';
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Name',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) return 'Please enter a name';
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _ageController,
                decoration: const InputDecoration(
                  labelText: 'Age (Optional)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _breedController,
                decoration: const InputDecoration(
                  labelText: 'Breed (Optional)',
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _personalityController,
                decoration: const InputDecoration(
                  labelText: 'Personality (Optional)',
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _foodSourceController,
                decoration: const InputDecoration(
                  labelText: 'Food Source (Optional)',
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 16),
              if (_petFields[_selectedPetType] != null) ...[
                const Text(
                  'Additional Information (Optional)',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                ...(_petFields[_selectedPetType] ?? []).map((field) {
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 16.0),
                    child: TextFormField(
                      controller: _additionalFieldControllers['$_selectedPetType-$field'],
                      decoration: InputDecoration(
                        labelText: field,
                        border: const OutlineInputBorder(),
                      ),
                    ),
                  );
                }),
              ],
              const SizedBox(height: 16),
              const Text(
                'Custom Fields (Optional)',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              ..._customFields.map((entry) {
                return Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: TextFormField(
                    controller: entry.value,
                    decoration: InputDecoration(
                      labelText: entry.key,
                      border: const OutlineInputBorder(),
                    ),
                  )
                );
              }),
              TextButton(
                onPressed: _addCustomField,
                child: const Text('Add Custom Field'),
              ),
              const SizedBox(height: 16),
              RoundedButton(
                text: 'Create Pet Profile',
                onPressed: _submitForm,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

--- lib/views/main_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/user_provider.dart';
import 'community_feed_screen.dart';
import 'ask_ai_screen.dart';
import 'tracking_screen.dart';
import 'profile_settings_screen.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({super.key});

  @override
  _MainScreenState createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int _selectedIndex = 0;

  static final List<Widget> _pages = <Widget>[
    const CommunityFeedScreen(),
    const AskAiScreen(),
    const TrackingScreen(),
    const ProfileSettingsScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    if (!userProvider.isLoggedIn) {
      return const Scaffold(body: Center(child: Text('Please log in')));
    }

    return Scaffold(
      body: IndexedStack(
        index: _selectedIndex,
        children: _pages,
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(icon: Icon(Icons.feed), label: 'Feed'),
          BottomNavigationBarItem(icon: Icon(Icons.question_answer), label: 'Ask AI'),
          BottomNavigationBarItem(icon: Icon(Icons.track_changes), label: 'Tracking'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }
}

--- lib/views/home_screen.dart ---
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/user_provider.dart';
import 'community_feed_screen.dart';
import 'ask_ai_screen.dart';
import 'shopping_list_screen.dart';
import 'tracking_screen.dart';
import 'profile_settings_screen.dart';
import 'welcome_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  _HomeScreenState createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _selectedIndex = 0;

  static final List<Widget> _pages = <Widget>[
    const CommunityFeedScreen(),
    const AskAiScreen(),
    const ShoppingListScreen(),
    const TrackingScreen(),
    const ProfileSettingsScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
      print('HomeScreen: Navigated to index $index');
    });
  }

  @override
  Widget build(BuildContext context) {
    print('HomeScreen: Building UI, selectedIndex: $_selectedIndex');
    final userProvider = Provider.of<UserProvider>(context);
    
    // Redirect to WelcomeScreen only if user is not logged in and not a guest
    if (!userProvider.isLoggedIn) {
      return const WelcomeScreen();
    }

    return Scaffold(
      body: _pages[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(icon: Icon(Icons.feed), label: 'Feed'),
          BottomNavigationBarItem(icon: Icon(Icons.question_answer), label: 'Ask AI'),
          BottomNavigationBarItem(icon: Icon(Icons.shopping_cart), label: 'Shopping'),
          BottomNavigationBarItem(icon: Icon(Icons.track_changes), label: 'Tracking'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Theme.of(context).colorScheme.secondary,
        unselectedItemColor: Colors.grey,
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }
}

--- lib/services/api_service.dart ---
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/pet.dart';
import '../models/post.dart';
import '../models/tracking_metric.dart';
import '../models/shopping_item.dart';

class ApiService {
  static final List<Map<String, dynamic>> _mockPosts = [
    {
      'id': 1,
      'title': 'Puppy Training 101',
      'content': 'Start with treats and patience to teach sit and stay.',
      'author': 'DogLover',
      'petType': 'Dog',
      'imageUrl': null,
      'upvotes': 50,
      'createdAt': DateTime.now().subtract(const Duration(days: 2)).toIso8601String(),
      'postType': 'reddit',
      'redditUrl': 'https://www.reddit.com/r/pets/comments/123456/puppy_training_101/',
      'comments': [],
    },
    {
      'id': 2,
      'title': 'Cat Scratching Fix',
      'content': 'A tall scratching post saved my couch!',
      'author': 'CatFan',
      'petType': 'Cat',
      'upvotes': 30,
      'createdAt': DateTime.now().subtract(const Duration(days: 1)).toIso8601String(),
      'postType': 'community',
      'redditUrl': null,
      'comments': [
        {'id': 1, 'content': 'Great tip!', 'author': 'User1', 'createdAt': DateTime.now().toIso8601String()},
      ],
    },
    {
      'id': 3,
      'title': 'Turtle Tank Setup',
      'content': 'Clean water and UVB light are must-haves.',
      'author': 'TurtleGuru',
      'petType': 'Turtle',
      'upvotes': 20,
      'createdAt': DateTime.now().subtract(const Duration(hours: 12)).toIso8601String(),
      'postType': 'reddit',
      'redditUrl': 'https://www.reddit.com/r/pets/comments/789012/turtle_tank_setup/',
      'comments': [],
    },
    {
      'id': 4,
      'title': 'Dog Park Vibes',
      'content': 'My pup had a blast chasing balls today.',
      'author': 'PetWalker',
      'petType': 'Dog',
      'upvotes': 45,
      'createdAt': DateTime.now().subtract(const Duration(hours: 6)).toIso8601String(),
      'postType': 'community',
      'redditUrl': null,
      'comments': [],
    },
    {
      'id': 5,
      'title': 'Cat Toy Picks',
      'content': 'My kitty loves feather wands and laser pointers.',
      'author': 'KittyMom',
      'petType': 'Cat',
      'upvotes': 25,
      'createdAt': DateTime.now().subtract(const Duration(hours: 3)).toIso8601String(),
      'postType': 'community',
      'redditUrl': null,
      'comments': [],
    },
  ];

  Future<void> signup(String email, String password) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('user_email', email);
    await prefs.setString('user_password', password);
    await prefs.setInt('user_id', DateTime.now().millisecondsSinceEpoch);
    await prefs.setString('pets', '[]');
    await prefs.setString('posts', jsonEncode(_mockPosts));
    if (kDebugMode) {
      print('ApiService.signup: User $email signed up, initialized pets and posts');
    }
  }

  Future<void> login(String email, String password) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final storedEmail = prefs.getString('user_email');
    final storedPassword = prefs.getString('user_password');
    if (storedEmail != email || storedPassword != password) {
      if (kDebugMode) {
        print('ApiService.login: Invalid credentials for $email');
      }
      throw Exception('Invalid credentials');
    }
    if (kDebugMode) {
      print('ApiService.login: User $email logged in');
    }
  }

  Future<List<Pet>> getPets() async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final petsJson = prefs.getString('pets') ?? '[]';
    if (kDebugMode) {
      print('ApiService.getPets: Retrieved pets JSON: $petsJson');
    }
    try {
      final List<dynamic> petsData = jsonDecode(petsJson);
      final pets = petsData.map((p) => Pet.fromJson(p)).toList();
      if (kDebugMode) {
        print('ApiService.getPets: Loaded ${pets.length} pets');
        for (var pet in pets) {
          print('ApiService.getPets: Pet ${pet.name}');
        }
      }
      return pets;
    } catch (e) {
      if (kDebugMode) {
        print('ApiService.getPets: Error decoding pets: $e');
      }
      return [];
    }
  }

  Future<void> createPet(Pet pet) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final petsJson = prefs.getString('pets') ?? '[]';
    final List<dynamic> petsData = jsonDecode(petsJson);
    final newPet = Pet(
      id: pet.id ?? (petsData.length + 1),
      name: pet.name,
      species: pet.species,
      breed: pet.breed,
      age: pet.age,
      personality: pet.personality,
      foodSource: pet.foodSource,
      favoritePark: pet.favoritePark,
      leashSource: pet.leashSource,
      litterType: pet.litterType,
      waterProducts: pet.waterProducts,
      tankSize: pet.tankSize,
      cageSize: pet.cageSize,
      favoriteToy: pet.favoriteToy,
      customFields: pet.customFields,
      shoppingList: pet.shoppingList,
      trackingMetrics: pet.trackingMetrics,
    );
    petsData.add(newPet.toJson());
    await prefs.setString('pets', jsonEncode(petsData));
    if (kDebugMode) {
      print('ApiService.createPet: Created pet ${newPet.name}');
    }
  }

  Future<void> updatePet(Pet pet) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final petsJson = prefs.getString('pets') ?? '[]';
    final List<dynamic> petsData = jsonDecode(petsJson);
    final index = petsData.indexWhere((p) => p['id'] == pet.id);
    if (index != -1) {
      petsData[index] = pet.toJson();
      await prefs.setString('pets', jsonEncode(petsData));
      if (kDebugMode) {
        print('ApiService.updatePet: Updated pet ${pet.id}');
      }
    } else {
      if (kDebugMode) {
        print('ApiService.updatePet: Pet ${pet.id} not found');
      }
    }
  }

  Future<List<Post>> getPosts({String? petType, String? postType}) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final postsJson = prefs.getString('posts') ?? jsonEncode(_mockPosts);
    final List<dynamic> postsData = jsonDecode(postsJson);
    var posts = postsData.map((p) => Post.fromJson(p)).toList();
    if (petType != null) {
      posts = posts.where((p) => p.petType == petType).toList();
    }
    if (postType != null) {
      posts = posts.where((p) => p.postType == postType.toLowerCase()).toList();
    }
    if (kDebugMode) {
      print('ApiService.getPosts: Returning ${posts.length} posts for petType: $petType, postType: $postType');
    }
    return posts;
  }

  Future<void> createPost({
    required String title,
    required String content,
    required String petType,
    required String author,
    String? imageUrl,
  }) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final postsJson = prefs.getString('posts') ?? jsonEncode(_mockPosts);
    final List<dynamic> postsData = jsonDecode(postsJson);
    final newPost = Post(
      id: postsData.length + 1,
      title: title,
      content: content,
      author: author,
      petType: petType,
      imageUrl: imageUrl,
      upvotes: 0,
      createdAt: DateTime.now(),
      postType: 'community',
      redditUrl: null,
    );
    postsData.add(newPost.toJson());
    await prefs.setString('posts', jsonEncode(postsData));
    if (kDebugMode) {
      print('ApiService.createPost: Created post ${newPost.id}');
    }
  }

  Future<void> addComment({
    required int postId,
    required String content,
    required String author,
  }) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final postsJson = prefs.getString('posts') ?? jsonEncode(_mockPosts);
    final List<dynamic> postsData = jsonDecode(postsJson);
    final index = postsData.indexWhere((p) => p['id'] == postId);
    if (index != -1) {
      final post = Post.fromJson(postsData[index]);
      final newComment = Comment(
        id: post.comments.length + 1,
        content: content,
        author: author,
        createdAt: DateTime.now(),
      );
      post.comments.add(newComment);
      postsData[index] = post.toJson();
      await prefs.setString('posts', jsonEncode(postsData));
      if (kDebugMode) {
        print('ApiService.addComment: Added comment to post $postId');
      }
    }
  }

  Future<Post> getPost(int postId) async {
    await Future.delayed(const Duration(seconds: 1));
    final prefs = await SharedPreferences.getInstance();
    final postsJson = prefs.getString('posts') ?? jsonEncode(_mockPosts);
    final List<dynamic> postsData = jsonDecode(postsJson);
    final postData = postsData.firstWhere((p) => p['id'] == postId, orElse: () => null);
    if (postData == null) throw Exception('Post not found');
    return Post.fromJson(postData);
  }
}

--- lib/widgets/rounded_button.dart ---
import 'package:flutter/material.dart';

class RoundedButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;

  const RoundedButton({super.key, required this.text, this.onPressed});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30.0)),
      ),
      child: Text(text),
    );
  }
}
